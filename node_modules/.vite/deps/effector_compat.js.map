{
  "version": 3,
  "sources": ["../../.pnpm/effector@22.8.0/node_modules/effector/effector/collection.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/throw.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/region.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/createNode.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/tag.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/kernel.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/naming.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/config.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/template.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/createUnit.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/combine.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/defer.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/createEffect.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/merge.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/sample.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fork/util.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/createWatch.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/observable.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/getter.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/validate.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/id.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/own.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/is.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/caller.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/step.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/stateRef.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/clearNode.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/subscription.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/forward.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/watch.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/split.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fork/serialize.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fork/allSettled.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/attach.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/createApi.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/createDomain.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fork/fork.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fork/createScope.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fromObservable.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/guard.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fork/hydrate.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/restore.ts", "../../.pnpm/effector@22.8.0/node_modules/effector/effector/fork/scopeBind.ts"],
  "sourcesContent": ["export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n", "export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n", "import type {Template} from '../forest/index.h'\nimport type {NodeUnit, Node, ID} from './index.h'\nimport {getParent, getGraph} from './getter'\nimport {createNode} from './createNode'\n\ntype DeclarationSourceReporter = (\n  node: Node | 'region',\n  regionStack: RegionStack | null,\n) => void\n\nlet reporter: DeclarationSourceReporter\n\nexport const setGraphInspector = (fn: DeclarationSourceReporter) => {\n  reporter = fn\n}\n\ntype RegionStack = {\n  id: ID\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n  meta:\n    | Record<string, unknown>\n    | {\n        type: 'factory'\n        sid?: string\n        name?: string\n        loc: unknown\n        method?: string\n      }\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const reportDeclaration = (node: Node | 'region') => {\n  if (reporter) {\n    reporter(node, regionStack)\n  }\n}\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion<T = void>(unit: NodeUnit, cb: () => T): T {\n  const meta = getGraph(unit).meta || {}\n\n  regionStack = {\n    id: getGraph(unit).id,\n    parent: regionStack,\n    value: unit,\n    template: meta.template || readTemplate(),\n    sidRoot: meta.sidRoot || (regionStack && regionStack.sidRoot),\n    meta: meta,\n  }\n  try {\n    return cb()\n  } finally {\n    reportDeclaration('region')\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const factoryRootNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), sid, name, loc, method, type: 'factory'},\n  })\n\n  return withRegion(factoryRootNode, fn)\n}\n", "import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n", "export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n", "import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  failReason?: unknown\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n  meta?: Record<string, any> | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n      meta,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\n/** Introspection api internals */\ntype Inspector = (stack: Stack, local: Local) => void\nlet inspector: Inspector\nexport const setInspector = (newInspector: Inspector) => {\n  inspector = newInspector\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void | null\n  stack?: Stack | void\n  meta?: Record<string, any> | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  let meta: Record<string, any> | void\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    meta = unit.meta\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n        meta,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n      meta,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (inspector) {\n      inspector(stack, local)\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'warnSerialize'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: Scope,\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  const serialize = sourceRef?.meta?.serialize\n  const parser =\n    scope.fromSerialize && serialize !== 'ignore'\n      ? serialize?.read || noopParser\n      : noopParser\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n    meta: sourceRef.meta,\n  }\n\n  if (sid && sid in scope.values.sidMap && !(sid in scope.sidIdMap)) {\n    ref.current = parser(scope.values.sidMap[sid])\n  } else if (ref.id in scope.values.idMap) {\n    ref.current = scope.values.idMap[ref.id]\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n    local.failReason = err\n  }\n}\n", "import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n", "import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n", "import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n", "import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot, reportDeclaration} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(config.actualOp || EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  reportDeclaration(finalEvent.graphite)\n  return finalEvent\n}\nfunction on<State>(\n  store: Store<State>,\n  methodName: string,\n  nodeSet: CommonUnit | CommonUnit[],\n  fn: Function,\n) {\n  assertNodeSet(nodeSet, methodName, 'first argument')\n  assert(isFunction(fn), 'second argument should be a function')\n  deprecate(\n    !getMeta(store, 'derived'),\n    `${methodName} in derived store`,\n    `${methodName} in store created via createStore`,\n  )\n  forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n    store.off(trigger)\n    getSubscribers(store).set(\n      trigger,\n      createSubscription(updateStore(trigger, store, 'on', callARegStack, fn)),\n    )\n  })\n  return store\n}\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit =>\n        on(store, '.reset', unit, () => store.defaultState),\n      )\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      return on(store, '.on', nodeSet, fn)\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        // @ts-expect-error some mismatch in config types\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta: {\n      ...meta,\n      defaultState,\n    },\n    regional: true,\n  })\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const customSerialize = !serializeMeta || ignored ? false : serializeMeta\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n\n    if (customSerialize) {\n      plainState.meta = {\n        ...plainState?.meta,\n        serialize: customSerialize,\n      }\n    }\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  assert(\n    derived || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>({\n      named: 'reinit',\n    })\n    store.reset(store.reinit)\n  }\n\n  reportDeclaration(store.graphite)\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n", "import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n", "import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n", "import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add, removeItem} from './collection'\nimport {flattenConfig} from './config'\nimport {nextEffectID} from './id'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig: any = {},\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    {...maybeConfig, actualOp: EFFECT},\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_: any, stack) => {\n          let handler: Function = scope_.handler\n          const scope = getForkPage(stack)\n          if (scope) {\n            const scopeHandler = instance.sid\n              ? scope.handlers.sidMap[instance.sid]\n              : scope.handlers.unitMap.get(instance)\n            if (scopeHandler) handler = scopeHandler\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          {\n            params,\n            req,\n            handler,\n            args = [params],\n          }: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          const scopeRef = createScopeRef(stack)\n          const onResolve = onSettled(\n            params,\n            req,\n            true,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const onReject = onSettled(\n            params,\n            req,\n            false,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n          ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        if (!stack.meta) {\n          stack.meta = {fxID: nextEffectID()}\n        }\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n          meta: stack.meta,\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n    }\n    launch({\n      target: instance,\n      params: payload,\n      scope: forkPage,\n    })\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const createScopeRef = (stack: Stack) => {\n  const scope = getForkPage(stack)\n  const scopeRef = {ref: scope}\n  if (scope) add(scope.activeEffects, scopeRef)\n  return scopeRef\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n    scopeRef: {ref: Scope | void},\n  ) =>\n  (data: any) => {\n    if (scopeRef.ref) removeItem(scopeRef.ref.activeEffects, scopeRef)\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: scopeRef.ref,\n      meta: stack.meta,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n", "import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n", "import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    // @ts-expect-error\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...readAndFilter(hasSource),\n      read(sourceRef, true, batched),\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n", "import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store, Effect, ValuesMap, HandlersMap} from '../unit.h'\nimport type {Node, Unit} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string | null) => void,\n  needSidlessStores: true,\n): void\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n): void\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n  needSidlessStores?: boolean,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE) {\n      if (needSidlessStores || getMeta(node, 'sid')) {\n        fn(node, getMeta(node, 'sid'))\n      }\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\ntype StoreOrEffect = Store<any> | Effect<any, any, any>\n\nexport function normalizeValues(\n  values: ValuesMap | HandlersMap,\n  assertEach?: (key: StoreOrEffect, value: any) => void,\n) {\n  const mapOrRecordValues: Map<StoreOrEffect, any> | Record<string, any> =\n    Array.isArray(values) ? new Map(values as [StoreOrEffect, any][]) : values\n  const unitMap = new Map<Unit<any>, any>()\n  if (mapOrRecordValues instanceof Map) {\n    const sidMap = {} as Record<string, any>\n    forEach(mapOrRecordValues, (value, key) => {\n      assert(\n        (is.unit as (val: unknown) => val is StoreOrEffect)(key),\n        'Map key should be a unit',\n      )\n      if (assertEach) assertEach(key, value)\n      if (key.sid) {\n        assert(!(key.sid in sidMap), 'duplicate sid found')\n        sidMap[key.sid!] = value\n      } else {\n        unitMap.set(key, value)\n      }\n    })\n    return {sidMap, unitMap}\n  }\n  return {sidMap: mapOrRecordValues, unitMap}\n}\n", "import {clearNode} from './clearNode'\nimport {createNode} from './createNode'\nimport type {Node, Subscription, Unit} from './index.h'\nimport {step} from './step'\nimport {Scope} from './unit.h'\n\nexport function createWatch<T>({\n  unit,\n  fn,\n  scope,\n}: {\n  unit: Unit<T>\n  fn: (value: T) => any\n  scope?: Scope\n}): Subscription {\n  const seq = [step.run({fn: value => fn(value)})]\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (unit as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return createSubscription(() => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    })\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [unit],\n      family: {owners: unit},\n    })\n    return createSubscription(() => {\n      clearNode(node)\n    })\n  }\n}\n\nfunction createSubscription(callback: () => void): Subscription {\n  const subscription: Subscription = () => callback()\n  subscription.unsubscribe = () => callback()\n\n  return subscription\n}\n", "export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n", "import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n", "import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n", "const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\nexport const nextEffectID = idCount()\n", "import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n", "export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n", "import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n", "import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n", "import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n", "import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n", "import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n", "import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n", "import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n", "import type {DataCarrier} from './unit.h'\nimport type {Cmd, Stack} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  assert(is.unit(source), 'source must be a unit')\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({derived: true, and: metadata})\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(METHOD, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        // @ts-expect-error\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n", "import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\nconst noopSerializer = (x: any) => x\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  if (scope.warnSerialize) {\n    console.error(\n      'There is a store without sid in this scope, its value is omitted',\n    )\n  }\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.values.sidMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    const serializeSettings = scope.sidSerializeSettings.get(sid) ?? {\n      ignore: false,\n      write: noopSerializer,\n    }\n    if (serializeSettings.ignore) return\n    const serializer = serializeSettings.write\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = serializer(scope.reg[id].current)\n    } else {\n      result[sid] = serializer(value)\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n", "import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope, Event, Effect, DataCarrier, SettledDefer} from '../unit.h'\n\nexport function allSettled<T>(\n  start: Event<T> | Effect<T, any, any> | Scope,\n  //@ts-expect-error its optional in correct cases\n  {scope, params: ctx}: {scope: Scope; params?: unknown} = {},\n) {\n  if (!is.unit(start))\n    return Promise.reject(new Error('first argument should be unit'))\n  if (\n    !is.effect(start) &&\n    !is.event(start) &&\n    !is.store(start) &&\n    !is.scope(start)\n  )\n    return Promise.reject(\n      new Error(\n        'first argument accepts only effects, events, stores or scopes',\n      ),\n    )\n  /** duplicated check because of ts validation */\n  if (is.scope(start)) {\n    scope = start\n  }\n  const defer = createDefer() as SettledDefer\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits: DataCarrier[] = []\n  const launchParams: Array<{params: unknown; req: unknown} | null> = []\n  if (!is.scope(start)) {\n    add(launchUnits, start)\n    add(\n      launchParams,\n      is.effect(start)\n        ? {\n            params: ctx,\n            req: {\n              rs(value: unknown) {\n                defer.value = {status: 'done', value}\n              },\n              rj(value: unknown) {\n                defer.value = {status: 'fail', value}\n              },\n            },\n          }\n        : ctx,\n    )\n  }\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n", "import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, createScopeRef, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName} from './naming'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const scopeRef = createScopeRef(stack)\n      const rj = onSettled(params, req, false, anyway, stack, scopeRef)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {\n                rs: onSettled(params, req, true, anyway, stack, scopeRef),\n                rj,\n              },\n            },\n            page: stack.page,\n            defer: true,\n            meta: stack.meta,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n", "import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n", "import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createNamedEvent,\n  createStore,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\nimport {flattenConfig} from './config'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n    parent: config?.domain || config?.parent,\n  })\n\n  const domain = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  } as Domain\n\n  node.meta = initUnit(DOMAIN, domain, {\n    parent: config?.domain || config?.parent,\n    or: config,\n  })\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase() as\n        | 'event'\n        | 'effect'\n        | 'store'\n        | 'domain'\n\n      const onCreateUnit = createNamedEvent(`on${tag}`)\n      domain.hooks[lowerCaseTag] = onCreateUnit\n\n      const history = new Set<any>()\n      domain.history[`${lowerCaseTag}s`] = history\n\n      onCreateUnit.create = unit => {\n        launch(onCreateUnit, unit)\n        return unit\n      }\n      add(\n        getGraph(onCreateUnit).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      onCreateUnit.watch(unit => {\n        own(domain, [unit])\n        history.add(unit)\n        if (!unit.ownerSet) unit.ownerSet = history\n        if (!getParent(unit)) unit.parent = domain\n      })\n      own(domain, [onCreateUnit])\n\n      domain[`onCreate${tag}`] = (hook: (unit: any) => any) => {\n        forEach(history, hook)\n        return onCreateUnit.watch(hook)\n      }\n      domain[`create${tag}`] = domain[lowerCaseTag] = (\n        nameOrConfig: any,\n        rawConfig?: Config,\n      ) => {\n        const config = flattenConfig({and: rawConfig, or: nameOrConfig})\n        if (config?.domain) {\n          // @ts-expect-error complicated factory type\n          return factory(nameOrConfig, rawConfig)\n        }\n        // @ts-expect-error complicated factory type\n        return onCreateUnit(factory(nameOrConfig, {parent: domain, or: config}))\n      }\n    },\n  )\n\n  const parent = getParent(domain)\n  if (parent) {\n    forIn(domain.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  if (config?.domain) {\n    config.domain.hooks.domain(domain)\n  }\n  return domain\n}\n", "import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain, ValuesMap, HandlersMap, Scope, Store} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\nimport {forEach} from '../collection'\n\ntype ForkConfig = {\n  values?: ValuesMap\n  handlers?: HandlersMap\n  scope?: Scope\n}\n\nexport function fork(\n  domainOrConfig?: Domain | ForkConfig,\n  optionalConfig?: ForkConfig,\n) {\n  let config: ForkConfig | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    const oldScope = config.scope\n    if (oldScope) {\n      const activeEffects = oldScope.activeEffects\n      oldScope.activeEffects = []\n      scope.activeEffects = activeEffects\n      forEach(activeEffects, scopeRef => (scopeRef.ref = scope))\n    }\n    if (config.values) {\n      const {sidMap, unitMap} = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.values.sidMap, sidMap)\n      forEach(unitMap, (value, unit) => {\n        scope.values.idMap[(unit as Store<any>).stateRef.id] = value\n      })\n      scope.fromSerialize =\n        !Array.isArray(config.values) && !(config.values instanceof Map)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n", "import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope, SettledDefer, Store} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (\n          _,\n          scope: {\n            inFlight: number\n            fxID: number\n            defers: SettledDefer[]\n          },\n        ) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            (getParent(storeStack) &&\n              getMeta(getParent(storeStack).node, 'op') !== 'combine')\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.values.sidMap[sid] = value\n\n            const serialize = getMeta(storeNode, 'serialize')\n            if (serialize) {\n              if (serialize === 'ignore') {\n                forkPage.sidSerializeSettings.set(sid, {ignore: true})\n              } else {\n                forkPage.sidSerializeSettings.set(sid, {\n                  ignore: false,\n                  write: serialize.write,\n                })\n              }\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const warnSerializeNode = createNode({\n    node: [\n      calc((_, __, stack) => {\n        const forkPage = getForkPage(stack)\n        if (forkPage) {\n          const storeStack = getParent(stack)\n          if (storeStack) {\n            const storeNode = storeStack.node\n            if (\n              !getMeta(storeNode, 'isCombine') ||\n              (getParent(storeStack) &&\n                getMeta(getParent(storeStack).node, 'op') !== 'combine')\n            ) {\n              forkPage.warnSerialize = true\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    values: {sidMap: {}, idMap: {}},\n    sidIdMap: {},\n    sidSerializeSettings: new Map(),\n    getState(store: StateRef | Store<any>) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange, warnSerializeNode],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {sidMap: {}, unitMap: new Map()},\n    fxCount: forkInFlightCounter,\n    storeChange,\n    warnSerializeNode,\n    activeEffects: [],\n  }\n  return resultScope\n}\n", "import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n", "import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args: any[]) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n", "import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope, ValuesMap, Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: ValuesMap}) {\n  assert(isObject(values), 'values property should be an object')\n  const {sidMap, unitMap} = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(sidMap)\n  const storesRefIdMap: Record<string, Store<any>> = {}\n  forEach(unitMap as unknown as Map<Store<any>, any>, (_, unit) => {\n    storesRefIdMap[unit.stateRef.id] = unit\n  })\n  // Array.from(unitMap.keys(),\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(\n    traverseTarget!,\n    (node, sid) => {\n      // forkPage.sidIdMap[sid] = node.scope.state.id\n      if (sid && includes(valuesSidList, sid)) {\n        add(storeNodes, node)\n        const serializer = getMeta(node, 'serialize')\n        if (serializer && serializer !== 'ignore') {\n          sidMap[sid] = serializer.read(sidMap[sid])\n        }\n        add(storeValues, sidMap[sid])\n      } else if (node.scope.state.id in storesRefIdMap) {\n        add(storeNodes, node)\n        add(storeValues, unitMap.get(storesRefIdMap[node.scope.state.id]))\n      }\n    },\n    true,\n  )\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.values.sidMap, sidMap)\n  }\n}\n", "import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {deprecate} from './throw'\n\nexport function restore(obj: any, defaultState: any, config?: any) {\n  if (is.store(obj)) {\n    deprecate(false, 'restore($store)')\n    return obj\n  }\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n", "import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\nimport type {Unit} from '../index.h'\n\n/** bind event to scope */\nexport function scopeBind(\n  unit: Unit,\n  {scope, safe}: {scope?: Scope; safe?: true} = {},\n) {\n  assert(\n    scope || forkPage || safe,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n"],
  "mappings": "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",
  "names": ["forIn", "obj", "cb", "key", "forEach", "list", "fn", "assert", "condition", "message", "Error", "withRegion", "unit", "meta", "getGraph", "regionStack", "id", "parent", "value", "template", "readTemplate", "sidRoot", "reportDeclaration", "getParent", "createNode", "e", "t", "n", "node", "i", "child", "to", "target", "scope", "f", "c", "d", "family", "familyRaw", "type", "regional", "sources", "arrifyNodes", "from", "source", "links", "owners", "seq", "item", "add", "result", "nextNodeID", "next", "link", "getOwners", "owner", "getLinks", "own", "getValue", "launch", "payload", "upsert", "pageForLaunch", "currentPage", "stackForLaunch", "forkPageForLaunch", "forkPage", "params", "defer", "page", "getForkPage", "Array", "isArray", "length", "pushFirstHeapItem", "isRoot", "stop", "skip", "reg", "lastStartedState", "isWatch", "isPure", "g", "idx", "stack", "hasPageReg", "hasScopeReg", "local", "fail", "stepn", "step", "order", "priority", "barrierID", "fullID", "barriers", "has", "pushHeap", "delete", "data", "STACK", "store", "pageForRef", "getPageForRef", "initRefInScope", "softRead", "undefined", "readRef", "getPageRef", "current", "getMeta", "pure", "computationResult", "safe", "tryRun", "filter", "inspector", "finalValue", "nextNode", "fxCount", "storeChange", "warnSerializeNode", "additionalLinks", "deleteMin", "unitObjectName", "objOrArr", "method", "name", "comma", "is", "getCompositeName", "fullName", "toString", "createName", "path", "shortName", "composite", "concat", "processArgsToConfig", "args", "singleArgument", "rawConfig", "assertObject", "metadata", "or", "childConfig", "and", "unwrappedNestedValue", "isObject", "nested", "applyTemplate", "handlers", "callCreate", "oldPage", "setCurrentPage", "create", "createEvent", "nameOrConfig", "maybeConfig", "config", "flattenConfig", "event", "deprecate", "finalEvent", "Object", "assign", "graphite", "initUnit", "actualOp", "watch", "watchUnit", "map", "deriveEvent", "MAP", "userFnCall", "callStack", "filterMap", "calc", "isVoid", "prepend", "contramapped", "createLinkNode", "applyParentHook", "domain", "hooks", "on", "methodName", "nodeSet", "assertNodeSet", "isFunction", "trigger", "off", "getSubscribers", "set", "createSubscription", "updateStore", "callARegStack", "createStore", "defaultState", "props", "plainState", "createStateRef", "updates", "named", "derived", "plainStateId", "subscribers", "Map", "stateRef", "getState", "reachedPage", "targetRef", "setState", "state", "reset", "units", "currentSubscription", "get", "firstState", "lastResult", "storeState", "innerStore", "linkNode", "callStackAReg", "addRefOp", "getStoreState", "noInit", "eventOrFn", "subscription", "updateFilter", "defaultConfig", "upd", "_", "b", "read", "a", "mov", "serializeMeta", "ignored", "customSerialize", "sid", "setMeta", "serialize", "reinit", "combine", "handler", "stores", "structStoreShape", "shapeReady", "noArraySpread", "rawHandler", "slice", "storeCombination", "createDefer", "req", "Promise", "rs", "rj", "catch", "createEffect", "instance", "kind", "use", "runner", "getCurrent", "anyway", "finally", "done", "status", "error", "doneData", "failData", "getType", "scope_", "scopeHandler", "sidMap", "unitMap", "scopeRef", "createScopeRef", "onResolve", "onSettled", "onReject", "runFn", "then", "op", "fx", "fxID", "nextEffectID", "savedFork", "setForkPage", "inFlight", "x", "pending", "amount", "effect", "merge", "validateSampleConfig", "atLeastOneFieldExists", "sampleConfigFields", "field", "fieldErrorMessage", "traverseStores", "root", "needSidlessStores", "visit", "includes", "normalizeValues", "values", "assertEach", "mapOrRecordValues", "callback", "unsubscribe", "observableSymbol", "Symbol", "observable", "graph", "val", "compositeName", "removeItem", "pos", "indexOf", "splice", "push", "subject", "suggestion", "console", "idCount", "nextUnitID", "nextStepID", "reporter", "readSidRoot", "ownerUnit", "_link", "flat", "assertNodeSetItem", "valueName", "reason", "assertTarget", "targetField", "cmd", "batch", "nextBarrierID", "r", "compute", "run", "isEffect", "toStack", "samplerPriority", "isFilter", "ref", "before", "heap", "v", "getPriority", "ret", "l", "queue", "ix", "first", "last", "size", "bucket", "Set", "newForkPage", "newPage", "isGetState", "noopParser", "sourceRef", "isKernelCall", "refsMap", "_sourceRef$meta", "sidIdMap", "fromSerialize", "idMap", "isFresh", "needToAssign", "err", "failReason", "part", "removeFromNode", "currentNode", "targetNode", "clearNodeNormalized", "deep", "isDomainUnit", "pop", "clearMap", "clear", "clearNode", "ownerSet", "history", "events", "effects", "domains", "scopeFn", "hookType", "isDomain", "o", "s", "unitId", "thru", "subscribe", "observer", "nativeTemplate", "mapped", "caller", "storeRef", "reader", "needSpread", "clone", "stateNew", "rawShape", "storeStateRef", "rawShapeReader", "childRef", "defaultShape", "activeEffects", "ok", "sidechain", "createSampling", "clock", "batched", "targetMayBeStore", "filterRequired", "isUpward", "sourceIsClock", "filterType", "clockState", "filterNodes", "S", "syncSourceState", "filterRef", "readAndFilter", "hasSource", "jointNode", "src", "joint", "isSourceStore", "launchCase", "scopeTargets", "noopSerializer", "start", "_temp", "ctx", "reject", "parentFork", "defers", "launchUnits", "launchParams", "mapParams", "attached", "runnerSteps", "runnerFnStep", "computedParams", "sourceData", "isEffectHandler", "h", "parentDomain", "setters", "createDomain", "Event", "Effect", "Store", "Domain", "factory", "tag", "lowerCaseTag", "toLowerCase", "onCreateUnit", "hook", "scopeLinks", "domainOrConfig", "optionalConfig", "forkInFlightCounter", "resolve", "__", "storeStack", "storeNode", "sidSerializeSettings", "ignore", "write", "warnSerialize", "resultScope", "cloneOf", "oldScope", "opts", "observableItem", "disposer", "complete", "greedy", "valuesSidList", "getOwnPropertyNames", "storesRefIdMap", "traverseTarget", "storeNodes", "storeValues", "serializer", "savedForkPage", "ignoredStores", "serializeSettings", "onlyChanges", "newInspector", "rawName", "targets", "METHOD", "match", "configForm", "cases", "matchIsUnit", "matchIsFunction", "matchIsShape", "splitterSeq", "caseNames", "keys", "String", "lastValues", "needBarrier", "storeOrFn", "updater", "caseName", "splitterNode", "loc"]
}
