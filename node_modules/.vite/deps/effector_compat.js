import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/.pnpm/effector@22.8.0/node_modules/effector/compat.js
var require_compat = __commonJS({
  "node_modules/.pnpm/effector@22.8.0/node_modules/effector/compat.js"(exports) {
    function e(e2, r2) {
      for (var n2 in e2)
        r2(e2[n2], n2);
    }
    function r(e2, r2) {
      e2.forEach(r2);
    }
    function n(e2, r2) {
      if (!e2)
        throw Error(r2);
    }
    function t(e2, r2) {
      var n2 = A(e2).meta || {};
      ee = { id: A(e2).id, parent: ee, value: e2, template: n2.template || ne(), sidRoot: n2.sidRoot || ee && ee.sidRoot, meta: n2 };
      try {
        return r2();
      } finally {
        re("region"), ee = q(ee);
      }
    }
    function a(e2) {
      var n2 = void 0 === e2 ? {} : e2, t2 = n2.node, a2 = void 0 === t2 ? [] : t2, i2 = n2.parent, o2 = n2.child, u2 = void 0 === o2 ? n2.to || n2.target : o2, f2 = n2.scope, s2 = void 0 === f2 ? {} : f2, c2 = n2.meta, l2 = void 0 === c2 ? {} : c2, d2 = n2.family, p2 = void 0 === d2 ? { type: "regular" } : d2, v2 = n2.regional, m2 = ie(void 0 === i2 ? n2.from || n2.source : i2), g2 = ie(p2.links), h2 = ie(p2.owners), y2 = [];
      r(a2, function(e3) {
        return e3 && $(y2, e3);
      });
      var b2 = { id: Y(), seq: y2, next: ie(u2), meta: l2, scope: s2, family: { type: p2.type || "crosslink", links: g2, owners: h2 } };
      return r(g2, function(e3) {
        return $(O(e3), b2);
      }), r(h2, function(e3) {
        return $(z(e3), b2);
      }), r(m2, function(e3) {
        return $(e3.next, b2);
      }), v2 && ee && ae(N(ee), [b2]), b2;
    }
    function i(e2, n2, t2) {
      var a2, i2 = We, o2 = null, u2 = qe;
      if (e2.target && (n2 = e2.params, t2 = e2.defer, a2 = e2.meta, i2 = "page" in e2 ? e2.page : i2, e2.stack && (o2 = e2.stack), u2 = F(e2) || u2, e2 = e2.target), u2 && qe && u2 !== qe && (qe = null), Array.isArray(e2))
        for (var f2 = 0; f2 < e2.length; f2++)
          De("pure", i2, A(e2[f2]), o2, n2[f2], u2, a2);
      else
        De("pure", i2, A(e2), o2, n2, u2, a2);
      if (!t2 || Le) {
        var s2, c2, l2, d2, p2, v2, m2 = { isRoot: Le, currentPage: We, scope: qe, isWatch: Be, isPure: Te };
        Le = 0;
        for (var g2 = function() {
          var e3 = d2.idx, n3 = d2.stack, t3 = d2.type;
          l2 = n3.node, We = p2 = n3.page, qe = F(n3), p2 ? v2 = p2.reg : qe && (v2 = qe.reg);
          var a3 = !!p2, i3 = !!qe, o3 = { fail: 0, scope: l2.scope };
          s2 = c2 = 0;
          for (var u3 = e3; u3 < l2.seq.length && !s2; u3++) {
            var f3 = l2.seq[u3];
            if (f3.order) {
              var g3 = f3.order, h2 = g3.priority, y2 = g3.barrierID, b2 = y2 ? p2 ? p2.fullID + "_" + y2 : y2 : 0;
              if (u3 !== e3 || t3 !== h2)
                return y2 ? Pe.has(b2) || (Pe.add(b2), Ee(u3, n3, h2, y2)) : Ee(u3, n3, h2), "continue|kernelLoop";
              y2 && Pe.delete(b2);
            }
            switch (f3.type) {
              case "mov":
                var x2 = f3.data, w2 = void 0;
                switch (x2.from) {
                  case j:
                    w2 = N(n3);
                    break;
                  case "a":
                  case "b":
                    w2 = n3[x2.from];
                    break;
                  case "value":
                    w2 = x2.store;
                    break;
                  case "store":
                    if (v2 && !v2[x2.store.id])
                      if (a3) {
                        var k2 = Ue(p2, x2.store.id);
                        n3.page = p2 = k2, k2 ? v2 = k2.reg : i3 ? (Je(qe, x2.store, 0, 1, x2.softRead), v2 = qe.reg) : v2 = void 0;
                      } else
                        i3 && Je(qe, x2.store, 0, 1, x2.softRead);
                    w2 = Ae(v2 && v2[x2.store.id] || x2.store);
                }
                switch (x2.to) {
                  case j:
                    n3.value = w2;
                    break;
                  case "a":
                  case "b":
                    n3[x2.to] = w2;
                    break;
                  case "store":
                    Ve(p2, qe, l2, x2.target).current = w2;
                }
                break;
              case "compute":
                var S2 = f3.data;
                if (S2.fn) {
                  Be = "watch" === R(l2, "op"), Te = S2.pure;
                  var M2 = S2.safe ? (0, S2.fn)(N(n3), o3.scope, n3) : Ke(o3, S2.fn, n3);
                  S2.filter ? c2 = !M2 : n3.value = M2, Be = m2.isWatch, Te = m2.isPure;
                }
            }
            s2 = o3.fail || c2;
          }
          if (Fe && Fe(n3, o3), !s2) {
            var A2 = N(n3), O2 = F(n3);
            if (r(l2.next, function(e4) {
              De("child", p2, e4, n3, A2, O2);
            }), O2) {
              R(l2, "needFxCounter") && De("child", p2, O2.fxCount, n3, A2, O2), R(l2, "storeChange") && De("child", p2, O2.storeChange, n3, A2, O2), R(l2, "warnSerialize") && De("child", p2, O2.warnSerializeNode, n3, A2, O2);
              var z2 = O2.additionalLinks[l2.id];
              z2 && r(z2, function(e4) {
                De("child", p2, e4, n3, A2, O2);
              });
            }
          }
        }; d2 = Re(); )
          g2();
        Le = m2.isRoot, We = m2.currentPage, qe = F(m2);
      }
    }
    function o(r2, n2) {
      void 0 === n2 && (n2 = "combine");
      var t2 = n2 + "(", a2 = "", i2 = 0;
      return e(r2, function(e2) {
        i2 < 25 && (null != e2 && (t2 += a2, t2 += _(e2) ? E(e2).fullName : e2.toString()), i2 += 1, a2 = ", ");
      }), t2 + ")";
    }
    function u(e2, r2) {
      var n2, t2, a2 = e2;
      if (r2) {
        var i2 = E(r2);
        0 === e2.length ? (n2 = i2.path, t2 = i2.fullName) : (n2 = i2.path.concat([e2]), t2 = 0 === i2.fullName.length ? e2 : i2.fullName + "/" + e2);
      } else
        n2 = 0 === e2.length ? [] : [e2], t2 = e2;
      return { shortName: a2, fullName: t2, path: n2 };
    }
    function f(e2, r2) {
      var n2 = r2 ? e2 : e2[0];
      se(n2);
      var t2 = n2.or, a2 = n2.and;
      if (a2) {
        var i2 = r2 ? a2 : a2[0];
        if (oe(i2) && "and" in i2) {
          var o2 = f(a2, r2);
          e2 = o2[0], t2 = Object.assign({}, t2, o2[1]);
        } else
          e2 = a2;
      }
      return [e2, t2];
    }
    function s(e2) {
      var r2 = ne();
      if (r2) {
        for (var n2 = r2.handlers[e2], t2 = arguments.length, a2 = new Array(t2 > 1 ? t2 - 1 : 0), i2 = 1; i2 < t2; i2++)
          a2[i2 - 1] = arguments[i2];
        if (n2)
          return n2.apply(void 0, [r2].concat(a2));
      }
    }
    function c(e2, r2, n2, t2) {
      var a2 = We, i2 = null;
      if (r2)
        for (i2 = We; i2 && i2.template !== r2; )
          i2 = q(i2);
      He(i2);
      var o2 = e2.create(n2, t2);
      return He(a2), o2;
    }
    function l(e2, r2) {
      var n2 = Qe({ or: r2, and: "string" == typeof e2 ? { name: e2 } : e2 }), t2 = function e3(r3) {
        J(!R(e3, "derived"), "call of derived event", "createEvent"), J(!Te, "unit call from pure function", "operators like sample");
        for (var n3 = arguments.length, t3 = new Array(n3 > 1 ? n3 - 1 : 0), a2 = 1; a2 < n3; a2++)
          t3[a2 - 1] = arguments[a2];
        return We ? c(e3, o2, r3, t3) : e3.create(r3, t3);
      }, o2 = ne(), u2 = Object.assign(t2, { graphite: a({ meta: ir(n2.actualOp || "event", t2, n2), regional: 1 }), create: function(e3) {
        return i({ target: t2, params: e3, scope: qe }), e3;
      }, watch: function(e3) {
        return tr(t2, e3);
      }, map: function(e3) {
        return or(t2, M, e3, [Se()]);
      }, filter: function(e3) {
        return or(t2, "filter", e3.fn ? e3 : e3.fn, [Se(me, 1)]);
      }, filterMap: function(e3) {
        return or(t2, "filterMap", e3, [Se(), we(function(e4) {
          return !fe(e4);
        }, 1)]);
      }, prepend: function(e3) {
        var r3 = l("* → " + t2.shortName, { parent: q(t2) });
        return s("eventPrepend", A(r3)), nr(r3, t2, [Se()], "prepend", e3), ar(t2, r3), r3;
      } });
      return null != n2 && n2.domain && n2.domain.hooks.event(u2), re(u2.graphite), u2;
    }
    function d(e2, t2, a2, i2) {
      return le(a2, t2, "first argument"), n(ue(i2), "second argument should be a function"), J(!R(e2, "derived"), t2 + " in derived store", t2 + " in store created via createStore"), r(Array.isArray(a2) ? a2 : [a2], function(r2) {
        e2.off(r2), I(e2).set(r2, rr(ur(r2, e2, "on", ve, i2)));
      }), e2;
    }
    function p(e2, t2) {
      var o2 = Qe(t2), u2 = je(e2), f2 = l({ named: "updates", derived: 1 });
      s("storeBase", u2);
      var c2 = u2.id, v2 = { subscribers: /* @__PURE__ */ new Map(), updates: f2, defaultState: e2, stateRef: u2, getState: function() {
        var e3, r2 = u2;
        if (We) {
          for (var n2 = We; n2 && !n2.reg[c2]; )
            n2 = q(n2);
          n2 && (e3 = n2);
        }
        return !e3 && qe && (Je(qe, u2, 1), e3 = qe), e3 && (r2 = e3.reg[c2]), Ae(r2);
      }, setState: function(e3) {
        return i({ target: v2, params: e3, defer: 1, scope: qe });
      }, reset: function() {
        for (var e3 = arguments.length, n2 = new Array(e3), t3 = 0; t3 < e3; t3++)
          n2[t3] = arguments[t3];
        return r(n2, function(e4) {
          return d(v2, ".reset", e4, function() {
            return v2.defaultState;
          });
        }), v2;
      }, on: function(e3, r2) {
        return d(v2, ".on", e3, r2);
      }, off: function(e3) {
        var r2 = I(v2).get(e3);
        return r2 && (r2(), I(v2).delete(e3)), v2;
      }, map: function(e3, r2) {
        var n2, t3;
        oe(e3) && (n2 = e3, e3 = e3.fn), J(fe(r2), "second argument of store.map", "updateFilter");
        var a2 = v2.getState();
        ne() ? t3 = null : fe(a2) || (t3 = e3(a2, r2));
        var i2 = p(t3, { name: v2.shortName + " → *", derived: 1, and: n2 }), o3 = ur(v2, i2, M, pe, e3);
        return Oe(C(i2), { type: M, fn: e3, from: u2 }), C(i2).noInit = 1, s("storeMap", u2, o3), i2;
      }, watch: function(e3, r2) {
        if (!r2 || !_(e3)) {
          var t3 = tr(v2, e3);
          return s("storeWatch", u2, e3) || e3(v2.getState()), t3;
        }
        return n(ue(r2), "second argument should be a function"), e3.watch(function(e4) {
          return r2(v2.getState(), e4);
        });
      } }, m2 = ir("store", v2, o2), g2 = v2.defaultConfig.updateFilter;
      v2.graphite = a({ scope: { state: u2, fn: g2 }, node: [we(function(e3, r2, n2) {
        return n2.scope && !n2.scope.reg[u2.id] && (n2.b = 1), e3;
      }), ke(u2), we(function(e3, r2, n2) {
        var t3 = n2.a, a2 = n2.b;
        return !fe(e3) && (e3 !== t3 || a2);
      }, 1), g2 && Se(pe, 1), ye({ from: j, target: u2 })], child: f2, meta: Object.assign({}, m2, { defaultState: e2 }), regional: 1 });
      var h2 = R(v2, "serialize"), y2 = R(v2, "derived"), b2 = "ignore" === h2, x2 = !h2 || b2 ? 0 : h2, w2 = R(v2, "sid");
      return w2 && (D(v2, "storeChange", 1), u2.sid = w2, x2 && (u2.meta = Object.assign({}, null == u2 ? void 0 : u2.meta, { serialize: x2 }))), w2 || b2 || y2 || D(v2, "warnSerialize", 1), n(y2 || !fe(e2), "current state can't be undefined, use null instead"), ae(v2, [f2]), null != o2 && o2.domain && o2.domain.hooks.store(v2), y2 || (v2.reinit = l({ named: "reinit" }), v2.reset(v2.reinit)), re(v2.graphite), v2;
    }
    function v() {
      for (var e2 = arguments.length, r2 = new Array(e2), t2 = 0; t2 < e2; t2++)
        r2[t2] = arguments[t2];
      var a2, i2, o2, u2 = f(r2);
      o2 = u2[1];
      var s2, c2, l2, d2 = (r2 = u2[0])[r2.length - 1];
      if (ue(d2) ? (i2 = r2.slice(0, -1), a2 = d2) : i2 = r2, 1 === i2.length) {
        var p2 = i2[0];
        L(p2) || (s2 = p2, c2 = 1);
      }
      if (!c2 && (s2 = i2, a2)) {
        l2 = 1;
        var v2 = a2;
        a2 = function(e3) {
          return v2.apply(void 0, e3);
        };
      }
      return n(oe(s2), "shape should be an object"), fr(Array.isArray(s2), !l2, s2, o2, a2);
    }
    function m() {
      var e2 = {};
      return e2.req = new Promise(function(r2, n2) {
        e2.rs = r2, e2.rj = n2;
      }), e2.req.catch(function() {
      }), e2;
    }
    function g(e2, r2) {
      void 0 === r2 && (r2 = {});
      var t2 = Qe(ue(e2) ? { handler: e2 } : e2, r2), o2 = l(ue(e2) ? { handler: e2 } : e2, Object.assign({}, r2, { actualOp: "effect" })), u2 = A(o2);
      D(u2, "op", o2.kind = "effect"), o2.use = function(e3) {
        return n(ue(e3), ".use argument should be a function"), g2.scope.handler = e3, o2;
      }, o2.use.getCurrent = function() {
        return g2.scope.handler;
      };
      var f2 = o2.finally = l({ named: "finally", derived: 1 }), s2 = o2.done = f2.filterMap({ named: "done", fn: function(e3) {
        if ("done" === e3.status)
          return { params: e3.params, result: e3.result };
      } }), c2 = o2.fail = f2.filterMap({ named: "fail", fn: function(e3) {
        if ("fail" === e3.status)
          return { params: e3.params, error: e3.error };
      } }), d2 = o2.doneData = s2.map({ named: "doneData", fn: function(e3) {
        return e3.result;
      } }), v2 = o2.failData = c2.map({ named: "failData", fn: function(e3) {
        return e3.error;
      } }), g2 = a({ scope: { handler: o2.defaultConfig.handler || function() {
        return n(0, "no handler used in " + o2.getType());
      } }, node: [we(function(e3, r3, n2) {
        var t3 = r3.handler, a2 = F(n2);
        if (a2) {
          var i2 = o2.sid ? a2.handlers.sidMap[o2.sid] : a2.handlers.unitMap.get(o2);
          i2 && (t3 = i2);
        }
        return e3.handler = t3, e3;
      }, 0, 1), we(function(e3, r3, n2) {
        var t3 = e3.params, a2 = e3.req, i2 = e3.handler, o3 = e3.args, u3 = void 0 === o3 ? [t3] : o3, s3 = cr(n2), c3 = lr(t3, a2, 1, f2, n2, s3), l2 = lr(t3, a2, 0, f2, n2, s3), d3 = sr(i2, l2, u3), p2 = d3[1];
        d3[0] && (oe(p2) && ue(p2.then) ? p2.then(c3, l2) : c3(p2));
      }, 0, 1)], meta: { op: "fx", fx: "runner" } });
      u2.scope.runner = g2, $(u2.seq, we(function(e3, r3, n2) {
        var t3 = r3.runner, a2 = q(n2) ? { params: e3, req: { rs: function() {
        }, rj: function() {
        } } } : e3;
        return n2.meta || (n2.meta = { fxID: Z() }), i({ target: t3, params: a2, defer: 1, scope: F(n2), meta: n2.meta }), a2.params;
      }, 0, 1)), o2.create = function(e3) {
        var r3 = m(), n2 = { params: e3, req: r3 };
        if (qe && !Be) {
          var t3 = qe;
          r3.req.finally(function() {
            Ge(t3);
          }).catch(function() {
          });
        }
        return i({ target: o2, params: n2, scope: qe }), r3.req;
      };
      var h2 = o2.inFlight = p(0, { serialize: "ignore" }).on(o2, function(e3) {
        return e3 + 1;
      }).on(f2, function(e3) {
        return e3 - 1;
      }).map({ fn: function(e3) {
        return e3;
      }, named: "inFlight" });
      D(f2, "needFxCounter", "dec"), D(o2, "needFxCounter", 1);
      var y2 = o2.pending = h2.map({ fn: function(e3) {
        return e3 > 0;
      }, named: "pending" });
      return ae(o2, [f2, s2, c2, d2, v2, y2, h2]), null != t2 && t2.domain && t2.domain.hooks.effect(o2), o2;
    }
    function h(e2, r2) {
      le(e2, "merge", "first argument");
      var n2 = l({ name: o(e2, "merge"), derived: 1, and: r2 });
      return nr(e2, n2, [], "merge"), n2;
    }
    function y(e2, t2) {
      var a2 = 0;
      return r(pr, function(r2) {
        r2 in e2 && (n(null != e2[r2], vr(t2, r2)), a2 = 1);
      }), a2;
    }
    function b(e2, n2, t2) {
      var a2 = [];
      (function e3(i2) {
        U(a2, i2) || ($(a2, i2), "store" === R(i2, "op") && (t2 || R(i2, "sid")) && n2(i2, R(i2, "sid")), r(i2.next, e3), r(O(i2), e3), r(z(i2), e3));
      })(e2);
    }
    function x(e2, t2) {
      var a2 = Array.isArray(e2) ? new Map(e2) : e2, i2 = /* @__PURE__ */ new Map();
      if (a2 instanceof Map) {
        var o2 = {};
        return r(a2, function(e3, r2) {
          n(_(r2), "Map key should be a unit"), t2 && t2(r2, e3), r2.sid ? (n(!(r2.sid in o2), "duplicate sid found"), o2[r2.sid] = e3) : i2.set(r2, e3);
        }), { sidMap: o2, unitMap: i2 };
      }
      return { sidMap: a2, unitMap: i2 };
    }
    function w(e2) {
      var r2 = function() {
        return e2();
      };
      return r2.unsubscribe = function() {
        return e2();
      }, r2;
    }
    Object.defineProperty(exports, "__esModule", { value: 1 });
    for (S = "undefined" != typeof Symbol && Symbol.observable || "@@observable", M = "map", j = "stack", A = function(e2) {
      return e2.graphite || e2;
    }, O = function(e2) {
      return e2.family.owners;
    }, z = function(e2) {
      return e2.family.links;
    }, C = function(e2) {
      return e2.stateRef;
    }, N = function(e2) {
      return e2.value;
    }, I = function(e2) {
      return e2.subscribers;
    }, q = function(e2) {
      return e2.parent;
    }, F = function(e2) {
      return e2.scope;
    }, R = function(e2, r2) {
      return A(e2).meta[r2];
    }, D = function(e2, r2, n2) {
      return A(e2).meta[r2] = n2;
    }, E = function(e2) {
      return e2.compositeName;
    }, _ = function(e2) {
      return (ue(e2) || oe(e2)) && "kind" in e2;
    }, P = function(e2) {
      return function(r2) {
        return _(r2) && r2.kind === e2;
      };
    }, L = P("store"), B = P("event"), T = P("effect"), W = P("domain"), G = P("scope"), H = { __proto__: null, unit: _, store: L, event: B, effect: T, domain: W, scope: G, attached: function(e2) {
      return T(e2) && 1 == R(e2, "attached");
    } }, U = function(e2, r2) {
      return e2.includes(r2);
    }, V = function(e2, r2) {
      var n2 = e2.indexOf(r2);
      -1 !== n2 && e2.splice(n2, 1);
    }, $ = function(e2, r2) {
      return e2.push(r2);
    }, J = function(e2, r2, n2) {
      return !e2 && console.error(r2 + " is deprecated" + (n2 ? ", use " + n2 + " instead" : ""));
    }, K = function() {
      var e2 = 0;
      return function() {
        return "" + ++e2;
      };
    }, Q = K(), X = K(), Y = K(), Z = K(), ee = null, re = function(e2) {
      k && k(e2, ee);
    }, ne = function() {
      return ee && ee.template;
    }, te = function(e2) {
      return e2 && ee && ee.sidRoot && (e2 = ee.sidRoot + "|" + e2), e2;
    }, ae = function(e2, n2) {
      var t2 = A(e2);
      r(n2, function(e3) {
        var r2 = A(e3);
        "domain" !== t2.family.type && (r2.family.type = "crosslink"), $(O(r2), t2), $(z(t2), r2);
      });
    }, ie = function(e2) {
      return void 0 === e2 && (e2 = []), (Array.isArray(e2) ? e2 : [e2]).flat().map(A);
    }, oe = function(e2) {
      return "object" == typeof e2 && null !== e2;
    }, ue = function(e2) {
      return "function" == typeof e2;
    }, fe = function(e2) {
      return void 0 === e2;
    }, se = function(e2) {
      return n(oe(e2) || ue(e2), "expect first argument be an object");
    }, ce = function(e2, r2, t2, a2) {
      return n(!(!oe(e2) && !ue(e2) || !("family" in e2) && !("graphite" in e2)), r2 + ": expect " + t2 + " to be a unit (store, event or effect)" + a2);
    }, le = function(e2, n2, t2) {
      Array.isArray(e2) ? r(e2, function(e3, r2) {
        return ce(e3, n2, r2 + " item of " + t2, "");
      }) : ce(e2, n2, t2, " or array of units");
    }, de = function(e2, n2, t2) {
      return void 0 === t2 && (t2 = "target"), r(ie(n2), function(r2) {
        return J(!R(r2, "derived"), e2 + ': derived unit in "' + t2 + '"', "createEvent/createStore");
      });
    }, pe = function(e2, r2, n2) {
      return (0, r2.fn)(e2, n2.a);
    }, ve = function(e2, r2, n2) {
      return (0, r2.fn)(n2.a, e2);
    }, me = function(e2, r2) {
      return (0, r2.fn)(e2);
    }, ge = function(e2, r2, n2, t2) {
      var a2 = { id: X(), type: e2, data: r2 };
      return n2 && (a2.order = { priority: n2 }, t2 && (a2.order.barrierID = ++he)), a2;
    }, he = 0, ye = function(e2) {
      var r2 = e2.from, n2 = e2.target, t2 = e2.to;
      return ge("mov", { from: void 0 === r2 ? "store" : r2, store: e2.store, to: void 0 === t2 ? n2 ? "store" : j : t2, target: n2 }, e2.priority, e2.batch);
    }, be = function(e2) {
      var r2 = e2.safe, n2 = e2.filter, t2 = e2.pure;
      return ge("compute", { fn: e2.fn, safe: void 0 === r2 ? 0 : r2, filter: void 0 === n2 ? 0 : n2, pure: void 0 === t2 ? 0 : t2 }, e2.priority, e2.batch);
    }, xe = function(e2) {
      return be({ fn: e2.fn, priority: "effect" });
    }, we = function(e2, r2, n2) {
      return be({ fn: e2, safe: 1, filter: r2, priority: n2 && "effect" });
    }, ke = function(e2, r2, n2) {
      return ye({ store: e2, to: r2 ? j : "a", priority: n2 && "sampler", batch: 1 });
    }, Se = function(e2, r2) {
      return void 0 === e2 && (e2 = me), be({ fn: e2, pure: 1, filter: r2 });
    }, Me = { mov: ye, compute: be, filter: function(e2) {
      return be({ fn: e2.fn, filter: 1, pure: e2.pure });
    }, run: xe }, je = function(e2) {
      return { id: X(), current: e2 };
    }, Ae = function(e2) {
      return e2.current;
    }, Oe = function(e2, r2) {
      e2.before || (e2.before = []), $(e2.before, r2);
    }, ze = null, Ce = function e2(r2, n2) {
      return r2 ? n2 ? ((r2.v.type === n2.v.type && r2.v.id > n2.v.id || _e(r2.v.type) > _e(n2.v.type)) && (t2 = r2, r2 = n2, n2 = t2), t2 = e2(r2.r, n2), r2.r = r2.l, r2.l = t2, r2) : r2 : n2;
      var t2;
    }, Ne = [], Ie = 0; Ie < 6; )
      $(Ne, { first: null, last: null, size: 0 }), Ie += 1;
    var k;
    var S;
    var M;
    var j;
    var A;
    var O;
    var z;
    var C;
    var N;
    var I;
    var q;
    var F;
    var R;
    var D;
    var E;
    var _;
    var P;
    var L;
    var B;
    var T;
    var W;
    var G;
    var H;
    var U;
    var V;
    var $;
    var J;
    var K;
    var Q;
    var X;
    var Y;
    var Z;
    var ee;
    var re;
    var ne;
    var te;
    var ae;
    var ie;
    var oe;
    var ue;
    var fe;
    var se;
    var ce;
    var le;
    var de;
    var pe;
    var ve;
    var me;
    var ge;
    var he;
    var ye;
    var be;
    var xe;
    var we;
    var ke;
    var Se;
    var Me;
    var je;
    var Ae;
    var Oe;
    var ze;
    var Ce;
    var Ne;
    var Ie;
    var qe;
    var Fe;
    var Re = function() {
      for (var e2 = 0; e2 < 6; e2++) {
        var r2 = Ne[e2];
        if (r2.size > 0) {
          if (3 === e2 || 4 === e2) {
            r2.size -= 1;
            var n2 = ze.v;
            return ze = Ce(ze.l, ze.r), n2;
          }
          1 === r2.size && (r2.last = null);
          var t2 = r2.first;
          return r2.first = t2.r, r2.size -= 1, t2.v;
        }
      }
    };
    var De = function(e2, r2, n2, t2, a2, i2, o2) {
      return Ee(0, { a: null, b: null, node: n2, parent: t2, value: a2, page: r2, scope: i2, meta: o2 }, e2);
    };
    var Ee = function(e2, r2, n2, t2) {
      void 0 === t2 && (t2 = 0);
      var a2 = _e(n2), i2 = Ne[a2], o2 = { v: { idx: e2, stack: r2, type: n2, id: t2 }, l: null, r: null };
      3 === a2 || 4 === a2 ? ze = Ce(ze, o2) : (0 === i2.size ? i2.first = o2 : i2.last.r = o2, i2.last = o2), i2.size += 1;
    };
    var _e = function(e2) {
      switch (e2) {
        case "child":
          return 0;
        case "pure":
          return 1;
        case "read":
          return 2;
        case "barrier":
          return 3;
        case "sampler":
          return 4;
        case "effect":
          return 5;
        default:
          return -1;
      }
    };
    var Pe = /* @__PURE__ */ new Set();
    var Le = 1;
    var Be = 0;
    var Te = 0;
    var We = null;
    var Ge = function(e2) {
      qe = e2;
    };
    var He = function(e2) {
      We = e2;
    };
    var Ue = function(e2, r2) {
      if (e2) {
        for (; e2 && !e2.reg[r2]; )
          e2 = q(e2);
        if (e2)
          return e2;
      }
      return null;
    };
    var Ve = function(e2, r2, n2, t2, a2) {
      var i2 = Ue(e2, t2.id);
      return i2 ? i2.reg[t2.id] : r2 ? (Je(r2, t2, a2), r2.reg[t2.id]) : t2;
    };
    var $e = function(e2) {
      return e2;
    };
    var Je = function e2(n2, t2, a2, i2, o2) {
      var u2, f2 = n2.reg, s2 = t2.sid, c2 = null == t2 || null === (u2 = t2.meta) || void 0 === u2 ? void 0 : u2.serialize;
      if (!f2[t2.id]) {
        var l2 = { id: t2.id, current: t2.current, meta: t2.meta };
        if (s2 && s2 in n2.values.sidMap && !(s2 in n2.sidIdMap))
          l2.current = (n2.fromSerialize && "ignore" !== c2 && (null == c2 ? void 0 : c2.read) || $e)(n2.values.sidMap[s2]);
        else if (l2.id in n2.values.idMap)
          l2.current = n2.values.idMap[l2.id];
        else if (t2.before && !o2) {
          var d2 = 0, p2 = a2 || !t2.noInit || i2;
          r(t2.before, function(r2) {
            switch (r2.type) {
              case M:
                var t3 = r2.from;
                if (t3 || r2.fn) {
                  t3 && e2(n2, t3, a2, i2);
                  var o3 = t3 && f2[t3.id].current;
                  p2 && (l2.current = r2.fn ? r2.fn(o3) : o3);
                }
                break;
              case "field":
                d2 || (d2 = 1, l2.current = Array.isArray(l2.current) ? [].concat(l2.current) : Object.assign({}, l2.current)), e2(n2, r2.from, a2, i2), p2 && (l2.current[r2.field] = f2[f2[r2.from.id].id].current);
            }
          });
        }
        s2 && (n2.sidIdMap[s2] = t2.id), f2[t2.id] = l2;
      }
    };
    var Ke = function(e2, r2, n2) {
      try {
        return r2(N(n2), e2.scope, n2);
      } catch (t2) {
        console.error(t2), e2.fail = 1, e2.failReason = t2;
      }
    };
    var Qe = function r2(n2, t2) {
      return void 0 === t2 && (t2 = {}), oe(n2) && (r2(n2.or, t2), e(n2, function(e2, r3) {
        fe(e2) || "or" === r3 || "and" === r3 || (t2[r3] = e2);
      }), r2(n2.and, t2)), t2;
    };
    var Xe = function(e2, r2) {
      V(e2.next, r2), V(O(e2), r2), V(z(e2), r2);
    };
    var Ye = function e2(r2, n2, t2) {
      var a2;
      r2.next.length = 0, r2.seq.length = 0, r2.scope = null;
      for (var i2 = z(r2); a2 = i2.pop(); )
        Xe(a2, r2), (n2 || t2 && "sample" !== R(r2, "op") || "crosslink" === a2.family.type) && e2(a2, n2, "on" !== R(a2, "op") && t2);
      for (i2 = O(r2); a2 = i2.pop(); )
        Xe(a2, r2), t2 && "crosslink" === a2.family.type && e2(a2, n2, "on" !== R(a2, "op") && t2);
    };
    var Ze = function(e2) {
      return e2.clear();
    };
    var er = function(e2, r2) {
      var n2 = (void 0 === r2 ? {} : r2).deep, t2 = 0;
      if (e2.ownerSet && e2.ownerSet.delete(e2), L(e2))
        Ze(I(e2));
      else if (W(e2)) {
        t2 = 1;
        var a2 = e2.history;
        Ze(a2.events), Ze(a2.effects), Ze(a2.stores), Ze(a2.domains);
      }
      Ye(A(e2), !!n2, t2);
    };
    var rr = function(e2) {
      var r2 = function() {
        return er(e2);
      };
      return r2.unsubscribe = r2, r2;
    };
    var nr = function(e2, r2, n2, t2, i2) {
      return a({ node: n2, parent: e2, child: r2, scope: { fn: i2 }, meta: { op: t2 }, family: { owners: [e2, r2], links: r2 }, regional: 1 });
    };
    var tr = function(e2, r2) {
      return n(ue(r2), ".watch argument should be a function"), rr(a({ scope: { fn: r2 }, node: [xe({ fn: me })], parent: e2, meta: { op: "watch" }, family: { owners: e2 }, regional: 1 }));
    };
    var ar = function(e2, r2, n2) {
      void 0 === n2 && (n2 = "event"), q(e2) && q(e2).hooks[n2](r2);
    };
    var ir = function(e2, r2, n2) {
      var t2 = Qe(n2), a2 = "domain" === e2, i2 = Q(), o2 = t2.sid, f2 = void 0 === o2 ? null : o2, s2 = t2.named, c2 = void 0 === s2 ? null : s2, l2 = t2.domain, d2 = t2.parent, p2 = void 0 === d2 ? void 0 === l2 ? null : l2 : d2, v2 = c2 || t2.name || (a2 ? "" : i2), m2 = u(v2, p2), g2 = { op: r2.kind = e2, name: r2.shortName = v2, sid: r2.sid = te(f2), named: c2, unitId: r2.id = i2, serialize: t2.serialize, derived: t2.derived, config: t2 };
      if (r2.parent = p2, r2.compositeName = m2, r2.defaultConfig = t2, r2.thru = function(e3) {
        return J(0, "thru", "js pipe"), e3(r2);
      }, r2.getType = function() {
        return m2.fullName;
      }, !a2) {
        r2.subscribe = function(e3) {
          return se(e3), r2.watch(ue(e3) ? e3 : function(r3) {
            return e3.next && e3.next(r3);
          });
        }, r2[S] = function() {
          return r2;
        };
        var h2 = ne();
        h2 && (g2.nativeTemplate = h2);
      }
      return g2;
    };
    var or = function(e2, r2, n2, t2) {
      var a2;
      oe(n2) && (a2 = n2, n2 = n2.fn);
      var i2 = l({ name: e2.shortName + " → *", derived: 1, and: a2 });
      return nr(e2, i2, t2, r2, n2), i2;
    };
    var ur = function(e2, r2, n2, t2, a2) {
      var i2 = C(r2), o2 = ye({ store: i2, to: "a", priority: "read" });
      n2 === M && (o2.data.softRead = 1);
      var u2 = [o2, Se(t2)];
      return s("storeOnMap", i2, u2, L(e2) && C(e2)), nr(e2, r2, u2, n2, a2);
    };
    var fr = function(r2, t2, a2, i2, u2) {
      var f2 = r2 ? function(e2) {
        return [].concat(e2);
      } : function(e2) {
        return Object.assign({}, e2);
      }, c2 = r2 ? [] : {}, l2 = f2(c2), d2 = je(l2), v2 = je(1);
      d2.type = r2 ? "list" : "shape", d2.noInit = 1, s("combineBase", d2, v2);
      var m2 = p(l2, { name: o(a2), derived: 1, and: i2 }), g2 = C(m2);
      g2.noInit = 1, D(m2, "isCombine", 1);
      var h2 = ke(d2);
      h2.order = { priority: "barrier" };
      var y2 = [we(function(e2, r3, n2) {
        return n2.scope && !n2.scope.reg[d2.id] && (n2.c = 1), e2;
      }), h2, ye({ store: v2, to: "b" }), we(function(e2, r3, n2) {
        var a3 = r3.key;
        if (n2.c || e2 !== n2.a[a3])
          return t2 && n2.b && (n2.a = f2(n2.a)), n2.a[a3] = e2, 1;
      }, 1), ye({ from: "a", target: d2 }), ye({ from: "value", store: 0, target: v2 }), ye({ from: "value", store: 1, target: v2, priority: "barrier", batch: 1 }), ke(d2, 1), u2 && Se()];
      return e(a2, function(e2, r3) {
        if (!L(e2))
          return n(!_(e2) && !fe(e2), "combine expects a store in a field " + r3), void (l2[r3] = c2[r3] = e2);
        c2[r3] = e2.defaultState, l2[r3] = e2.getState();
        var t3 = nr(e2, m2, y2, "combine", u2);
        t3.scope.key = r3;
        var a3 = C(e2);
        Oe(d2, { type: "field", field: r3, from: a3 }), s("combineField", a3, t3);
      }), m2.defaultShape = a2, Oe(g2, { type: M, from: d2, fn: u2 }), ne() || (m2.defaultState = u2 ? g2.current = u2(l2) : c2), m2;
    };
    var sr = function(e2, r2, n2) {
      try {
        return [1, e2.apply(void 0, n2)];
      } catch (t2) {
        return r2(t2), [0, null];
      }
    };
    var cr = function(e2) {
      var r2 = F(e2), n2 = { ref: r2 };
      return r2 && $(r2.activeEffects, n2), n2;
    };
    var lr = function(e2, r2, n2, t2, a2, o2) {
      return function(u2) {
        o2.ref && V(o2.ref.activeEffects, o2), i({ target: [t2, dr], params: [n2 ? { status: "done", params: e2, result: u2 } : { status: "fail", params: e2, error: u2 }, { value: u2, fn: n2 ? r2.rs : r2.rj }], defer: 1, page: a2.page, scope: o2.ref, meta: a2.meta });
      };
    };
    var dr = a({ node: [xe({ fn: function(e2) {
      return (0, e2.fn)(e2.value);
    } })], meta: { op: "fx", fx: "sidechain" } });
    var pr = ["source", "clock", "target"];
    var vr = function(e2, r2) {
      return e2 + ": " + r2 + " should be defined";
    };
    var mr = function(e2, r2, t2, a2, i2, o2, u2, f2, c2, d2, m2, g2) {
      var y2 = !!i2;
      n(!fe(t2) || !fe(r2), vr(e2, "either source or clock"));
      var b2 = 0;
      fe(t2) ? b2 = 1 : _(t2) || (t2 = v(t2)), fe(r2) ? r2 = t2 : (le(r2, e2, "clock"), Array.isArray(r2) && (r2 = h(r2))), b2 && (t2 = r2), f2 || u2 || (u2 = t2.shortName);
      var x2 = "none";
      (m2 || a2) && (_(a2) ? x2 = "unit" : (n(ue(a2), "`filter` should be function or unit"), x2 = "fn")), i2 ? (le(i2, e2, "target"), de(e2, i2)) : "none" === x2 && d2 && L(t2) && L(r2) ? i2 = p(o2 ? o2(Ae(C(t2)), Ae(C(r2))) : Ae(C(t2)), { name: u2, sid: g2, or: f2 }) : (i2 = l({ name: u2, derived: 1, or: f2 }), s("sampleTarget", A(i2)));
      var w2 = je(), k2 = [];
      if ("unit" === x2) {
        var S2 = hr(a2, i2, r2, w2, e2), M2 = S2[0];
        k2 = [].concat(gr(S2[1]), gr(M2));
      }
      var O2 = hr(t2, i2, r2, w2, e2), z2 = O2[0], N2 = O2[1], I2 = nr(r2, i2, [s("sampleSourceLoader"), ye({ from: j, target: w2 })].concat(gr(N2), [ke(z2, 1, c2)], k2, [ke(w2), "fn" === x2 && Se(function(e3, r3, n2) {
        return a2(e3, n2.a);
      }, 1), o2 && Se(pe), s("sampleSourceUpward", y2)]), e2, o2);
      return ae(t2, [I2]), Object.assign(I2.meta, f2, { joint: 1 }), i2;
    };
    var gr = function(e2) {
      return [ke(e2), we(function(e3, r2, n2) {
        return n2.a;
      }, 1)];
    };
    var hr = function(e2, r2, n2, t2, i2) {
      var o2 = L(e2), u2 = o2 ? C(e2) : je(), f2 = je(o2);
      return o2 || a({ parent: e2, node: [ye({ from: j, target: u2 }), ye({ from: "value", store: 1, target: f2 })], family: { owners: [e2, r2, n2], links: r2 }, meta: { op: i2 }, regional: 1 }), s("sampleSource", f2, u2, t2), [u2, f2];
    };
    var yr = function(e2, r2, n2, t2) {
      var a2 = e2[r2];
      a2 && i({ target: a2, params: Array.isArray(a2) ? a2.map(function() {
        return n2;
      }) : n2, defer: 1, stack: t2 });
    };
    var br = function(e2) {
      return e2;
    };
    exports.allSettled = function(e2, r2) {
      var n2 = void 0 === r2 ? {} : r2, t2 = n2.scope, a2 = n2.params;
      if (!_(e2))
        return Promise.reject(new Error("first argument should be unit"));
      if (!(T(e2) || B(e2) || L(e2) || G(e2)))
        return Promise.reject(new Error("first argument accepts only effects, events, stores or scopes"));
      G(e2) && (t2 = e2);
      var o2 = m();
      o2.parentFork = qe;
      var u2 = t2.fxCount;
      $(u2.scope.defers, o2);
      var f2 = [], s2 = [];
      return G(e2) || ($(f2, e2), $(s2, T(e2) ? { params: a2, req: { rs: function(e3) {
        o2.value = { status: "done", value: e3 };
      }, rj: function(e3) {
        o2.value = { status: "fail", value: e3 };
      } } } : a2)), $(f2, u2), $(s2, null), i({ target: f2, params: s2, scope: t2 }), o2.req;
    }, exports.attach = function(e2) {
      var r2, n2 = f(e2, 1), t2 = (e2 = n2[0]).source, a2 = e2.effect, o2 = e2.mapParams, s2 = g(e2, n2[1]);
      D(s2, "attached", 1);
      var c2, l2, d2 = A(s2).scope.runner, p2 = we(function(e3, r3, n3) {
        var a3, u2 = e3.params, f2 = e3.req, c3 = e3.handler, l3 = s2.finally, d3 = cr(n3), p3 = lr(u2, f2, 0, l3, n3, d3), v2 = n3.a, m3 = T(c3), g2 = 1;
        if (o2) {
          var h2 = sr(o2, p3, [u2, v2]);
          g2 = h2[0], a3 = h2[1];
        } else
          a3 = t2 && m3 ? v2 : u2;
        if (g2) {
          if (!m3)
            return e3.args = [v2, a3], 1;
          i({ target: c3, params: { params: a3, req: { rs: lr(u2, f2, 1, l3, n3, d3), rj: p3 } }, page: n3.page, defer: 1, meta: n3.meta });
        }
      }, 1, 1);
      t2 ? (L(t2) ? ae(l2 = t2, [s2]) : (l2 = v(t2), ae(s2, [l2])), c2 = [ke(C(l2)), p2]) : c2 = [p2], (r2 = d2.seq).splice.apply(r2, [1, 0].concat(c2)), s2.use(a2);
      var m2 = q(a2);
      return m2 && (Object.assign(E(s2), u(s2.shortName, m2)), s2.defaultConfig.parent = m2), ar(a2, s2, "effect"), s2;
    }, exports.clearNode = er, exports.combine = v, exports.createApi = function() {
      for (var r2 = arguments.length, n2 = new Array(r2), t2 = 0; t2 < r2; t2++)
        n2[t2] = arguments[t2];
      var a2 = f(n2), i2 = a2[0], o2 = i2[0], u2 = i2[1], s2 = a2[1], c2 = {};
      return e(u2, function(e2, r3) {
        var n3 = c2[r3] = l(r3, { parent: q(o2), config: s2 });
        o2.on(n3, e2), ar(o2, n3);
      }), c2;
    }, exports.createDomain = function n2(t2, o2) {
      var u2 = Qe({ or: o2, and: "string" == typeof t2 ? { name: t2 } : t2 }), f2 = a({ family: { type: "domain" }, regional: 1, parent: (null == u2 ? void 0 : u2.domain) || (null == u2 ? void 0 : u2.parent) }), s2 = { history: {}, graphite: f2, hooks: {} };
      f2.meta = ir("domain", s2, { parent: (null == u2 ? void 0 : u2.domain) || (null == u2 ? void 0 : u2.parent), or: u2 }), e({ Event: l, Effect: g, Store: p, Domain: n2 }, function(e2, n3) {
        var t3 = n3.toLowerCase(), a2 = l({ named: "on" + n3 });
        s2.hooks[t3] = a2;
        var o3 = /* @__PURE__ */ new Set();
        s2.history[t3 + "s"] = o3, a2.create = function(e3) {
          return i(a2, e3), e3;
        }, $(A(a2).seq, we(function(e3, r2, n4) {
          return n4.scope = null, e3;
        })), a2.watch(function(e3) {
          ae(s2, [e3]), o3.add(e3), e3.ownerSet || (e3.ownerSet = o3), q(e3) || (e3.parent = s2);
        }), ae(s2, [a2]), s2["onCreate" + n3] = function(e3) {
          return r(o3, e3), a2.watch(e3);
        }, s2["create" + n3] = s2[t3] = function(r2, n4) {
          var t4 = Qe({ and: n4, or: r2 });
          return null != t4 && t4.domain ? e2(r2, n4) : a2(e2(r2, { parent: s2, or: t4 }));
        };
      });
      var c2 = q(s2);
      return c2 && e(s2.hooks, function(e2, r2) {
        return nr(e2, c2.hooks[r2]);
      }), null != u2 && u2.domain && u2.domain.hooks.domain(s2), s2;
    }, exports.createEffect = g, exports.createEvent = l, exports.createNode = a, exports.createStore = p, exports.createStoreObject = function() {
      return J(0, "createStoreObject", "combine"), v.apply(void 0, arguments);
    }, exports.createWatch = function(e2) {
      var r2 = e2.unit, n2 = e2.fn, t2 = e2.scope, i2 = [Me.run({ fn: function(e3) {
        return n2(e3);
      } })];
      if (t2) {
        var o2 = a({ node: i2 }), u2 = r2.graphite.id, f2 = t2.additionalLinks, s2 = f2[u2] || [];
        return f2[u2] = s2, s2.push(o2), w(function() {
          var e3 = s2.indexOf(o2);
          -1 !== e3 && s2.splice(e3, 1), er(o2);
        });
      }
      var c2 = a({ node: i2, parent: [r2], family: { owners: r2 } });
      return w(function() {
        er(c2);
      });
    }, exports.fork = function(e2, t2) {
      var i2, o2 = e2;
      W(e2) && (i2 = e2, o2 = t2);
      var u2 = function(e3) {
        var n2 = a({ scope: { defers: [], inFlight: 0, fxID: 0 }, node: [we(function(e4, r2, n3) {
          q(n3) ? "dec" === R(q(n3).node, "needFxCounter") ? r2.inFlight -= 1 : (r2.inFlight += 1, r2.fxID += 1) : r2.fxID += 1;
        }), be({ priority: "sampler", batch: 1 }), we(function(e4, n3) {
          var t4 = n3.defers, a2 = n3.fxID;
          n3.inFlight > 0 || 0 === t4.length || Promise.resolve().then(function() {
            n3.fxID === a2 && r(t4.splice(0, t4.length), function(e5) {
              Ge(e5.parentFork), e5.rs(e5.value);
            });
          });
        }, 0, 1)] }), t3 = a({ node: [we(function(e4, r2, n3) {
          var t4 = q(n3);
          if (t4) {
            var a2 = t4.node;
            if (!R(a2, "isCombine") || q(t4) && "combine" !== R(q(t4).node, "op")) {
              var i4 = F(n3), o4 = a2.scope.state.id, u3 = R(a2, "sid");
              i4.sidIdMap[u3] = o4, i4.values.sidMap[u3] = e4;
              var f3 = R(a2, "serialize");
              f3 && i4.sidSerializeSettings.set(u3, "ignore" === f3 ? { ignore: 1 } : { ignore: 0, write: f3.write });
            }
          }
        })] }), i3 = a({ node: [we(function(e4, r2, n3) {
          var t4 = F(n3);
          if (t4) {
            var a2 = q(n3);
            a2 && (!R(a2.node, "isCombine") || q(a2) && "combine" !== R(q(a2).node, "op")) && (t4.warnSerialize = 1);
          }
        })] }), o3 = { cloneOf: e3, reg: {}, values: { sidMap: {}, idMap: {} }, sidIdMap: {}, sidSerializeSettings: /* @__PURE__ */ new Map(), getState: function(e4) {
          if ("current" in e4)
            return Ve(We, o3, null, e4).current;
          var r2 = A(e4);
          return Ve(We, o3, r2, r2.scope.state, 1).current;
        }, kind: "scope", graphite: a({ family: { type: "domain", links: [n2, t3, i3] }, meta: { unit: "fork" }, scope: { forkInFlightCounter: n2 } }), additionalLinks: {}, handlers: { sidMap: {}, unitMap: /* @__PURE__ */ new Map() }, fxCount: n2, storeChange: t3, warnSerializeNode: i3, activeEffects: [] };
        return o3;
      }(i2);
      if (o2) {
        var f2 = o2.scope;
        if (f2) {
          var s2 = f2.activeEffects;
          f2.activeEffects = [], u2.activeEffects = s2, r(s2, function(e3) {
            return e3.ref = u2;
          });
        }
        if (o2.values) {
          var c2 = x(o2.values, function(e3) {
            return n(L(e3), "Values map can contain only stores as keys");
          }), l2 = c2.unitMap;
          Object.assign(u2.values.sidMap, c2.sidMap), r(l2, function(e3, r2) {
            u2.values.idMap[r2.stateRef.id] = e3;
          }), u2.fromSerialize = !(Array.isArray(o2.values) || o2.values instanceof Map);
        }
        o2.handlers && (u2.handlers = x(o2.handlers, function(e3) {
          return n(T(e3), "Handlers map can contain only effects as keys");
        }));
      }
      return u2;
    }, exports.forward = function(e2) {
      var r2 = "forward", n2 = f(e2, 1), t2 = n2[0], i2 = t2.from, o2 = t2.to, u2 = n2[1];
      return le(i2, r2, '"from"'), le(o2, r2, '"to"'), de(r2, o2, "to"), rr(a({ parent: i2, child: o2, meta: { op: r2, config: u2 }, family: {}, regional: 1 }));
    }, exports.fromObservable = function(e2) {
      se(e2);
      var r2 = S in e2 ? e2[S]() : e2;
      n(r2.subscribe, "expect observable to have .subscribe");
      var t2 = l(), a2 = rr(t2);
      return r2.subscribe({ next: t2, error: a2, complete: a2 }), t2;
    }, exports.guard = function() {
      for (var e2 = arguments.length, r2 = new Array(e2), n2 = 0; n2 < e2; n2++)
        r2[n2] = arguments[n2];
      var t2 = f(r2), a2 = t2[0], i2 = a2[0], o2 = a2[1], u2 = t2[1];
      return o2 || (i2 = (o2 = i2).source), y(o2, "guard"), mr("guard", o2.clock, i2, o2.filter, o2.target, null, o2.name, u2, !o2.greedy, 0, 1);
    }, exports.hydrate = function(e2, t2) {
      var a2 = t2.values;
      n(oe(a2), "values property should be an object");
      var o2 = x(a2), u2 = o2.sidMap, f2 = o2.unitMap, s2 = Object.getOwnPropertyNames(u2), c2 = {};
      r(f2, function(e3, r2) {
        c2[r2.stateRef.id] = r2;
      });
      var l2, d2, p2, v2 = [], m2 = [];
      G(e2) ? (p2 = 1, n((l2 = e2).cloneOf, "scope should be created from domain"), d2 = A(l2.cloneOf)) : W(e2) ? d2 = A(e2) : n(0, "first argument of hydrate should be domain or scope"), b(d2, function(e3, r2) {
        if (r2 && U(s2, r2)) {
          $(v2, e3);
          var n2 = R(e3, "serialize");
          n2 && "ignore" !== n2 && (u2[r2] = n2.read(u2[r2])), $(m2, u2[r2]);
        } else
          e3.scope.state.id in c2 && ($(v2, e3), $(m2, f2.get(c2[e3.scope.state.id])));
      }, 1), i({ target: v2, params: m2, scope: l2 }), p2 && Object.assign(l2.values.sidMap, u2);
    }, exports.is = H, exports.launch = i, exports.merge = h, exports.restore = function(r2, n2, t2) {
      if (L(r2))
        return J(0, "restore($store)"), r2;
      if (B(r2) || T(r2)) {
        var a2 = q(r2), i2 = p(n2, { parent: a2, name: r2.shortName, and: t2 });
        return nr(T(r2) ? r2.doneData : r2, i2), a2 && a2.hooks.store(i2), i2;
      }
      var o2 = Array.isArray(r2) ? [] : {};
      return e(r2, function(e2, r3) {
        return o2[r3] = L(e2) ? e2 : p(e2, { name: r3 });
      }), o2;
    }, exports.sample = function() {
      for (var e2, r2, n2 = arguments.length, t2 = new Array(n2), a2 = 0; a2 < n2; a2++)
        t2[a2] = arguments[a2];
      var i2, o2, u2 = f(t2), s2 = u2[0], c2 = s2[0], l2 = s2[1], d2 = s2[2], p2 = u2[1], v2 = 1;
      return fe(l2) && oe(c2) && y(c2, "sample") && (l2 = c2.clock, d2 = c2.fn, v2 = !c2.greedy, o2 = c2.filter, e2 = c2.target, r2 = c2.name, i2 = c2.sid, c2 = c2.source), mr("sample", l2, c2, o2, e2, d2, r2, p2, v2, 1, 0, i2);
    }, exports.scopeBind = function(e2, r2) {
      var t2 = void 0 === r2 ? {} : r2, a2 = t2.scope;
      n(a2 || qe || t2.safe, "scopeBind cannot be called outside of forked .watch");
      var o2 = a2 || qe;
      return T(e2) ? function(r3) {
        var n2 = m();
        return i({ target: e2, params: { params: r3, req: n2 }, scope: o2 }), n2.req;
      } : function(r3) {
        return i({ target: e2, params: r3, scope: o2 }), r3;
      };
    }, exports.serialize = function(r2, t2) {
      void 0 === t2 && (t2 = {}), r2.warnSerialize && console.error("There is a store without sid in this scope, its value is omitted");
      var a2 = t2.ignore ? t2.ignore.map(function(e2) {
        return e2.sid;
      }) : [], i2 = {};
      return e(r2.values.sidMap, function(e2, n2) {
        var t3;
        if (!U(a2, n2)) {
          var o2 = r2.sidIdMap[n2], u2 = null !== (t3 = r2.sidSerializeSettings.get(n2)) && void 0 !== t3 ? t3 : { ignore: 0, write: br };
          u2.ignore || (i2[n2] = (0, u2.write)(o2 && o2 in r2.reg ? r2.reg[o2].current : e2));
        }
      }), "onlyChanges" in t2 && !t2.onlyChanges && (n(r2.cloneOf, "scope should be created from domain"), b(A(r2.cloneOf), function(e2, n2) {
        n2 in i2 || U(a2, n2) || R(e2, "isCombine") || "ignore" === R(e2, "serialize") || (i2[n2] = r2.getState(e2));
      })), i2;
    }, exports.setGraphInspector = function(e2) {
      k = e2;
    }, exports.setInspector = function(e2) {
      Fe = e2;
    }, exports.setStoreName = function(e2, r2) {
      e2.shortName = r2, Object.assign(E(e2), u(r2, q(e2)));
    }, exports.split = function() {
      for (var r2, t2, i2 = "split", o2 = arguments.length, u2 = new Array(o2), c2 = 0; c2 < o2; c2++)
        u2[c2] = arguments[c2];
      var d2 = f(u2), p2 = d2[0], v2 = p2[0], m2 = p2[1], g2 = d2[1], h2 = !m2;
      h2 && (r2 = v2.cases, m2 = v2.match, t2 = v2.clock, v2 = v2.source);
      var y2 = L(m2), b2 = !_(m2) && ue(m2), x2 = !y2 && !b2 && oe(m2);
      n(_(v2), "source must be a unit"), r2 || (r2 = {}), h2 ? e(r2, function(e2, r3) {
        return de(i2, e2, "cases." + r3);
      }) : (n(x2, "match should be an object"), e(m2, function(e2, n2) {
        return r2[n2] = l({ derived: 1, and: g2 });
      }), r2.__ = l({ derived: 1, and: g2 }));
      var w2, k2 = new Set([].concat(v2, t2 || [], Object.values(r2))), S2 = Object.keys(y2 || b2 ? r2 : m2);
      if (y2 || b2)
        y2 && k2.add(m2), w2 = [y2 && ke(C(m2), 0, 1), be({ safe: y2, filter: 1, pure: !y2, fn: function(e2, r3, n2) {
          var t3 = String(y2 ? n2.a : m2(e2));
          yr(r3, U(S2, t3) ? t3 : "__", e2, n2);
        } })];
      else if (x2) {
        var M2 = je({});
        M2.type = "shape";
        var j2, A2 = [];
        e(m2, function(e2, r3) {
          if (_(e2)) {
            j2 = 1, $(A2, r3), k2.add(e2);
            var n2 = nr(e2, [], [ke(M2), we(function(e3, n3, t4) {
              return t4.a[r3] = e3;
            })]);
            if (L(e2)) {
              M2.current[r3] = e2.getState();
              var t3 = C(e2);
              Oe(M2, { from: t3, field: r3, type: "field" }), s("splitMatchStore", t3, n2);
            }
          }
        }), j2 && s("splitBase", M2), w2 = [j2 && ke(M2, 0, 1), Se(function(e2, r3, n2) {
          for (var t3 = 0; t3 < S2.length; t3++) {
            var a2 = S2[t3];
            if (U(A2, a2) ? n2.a[a2] : m2[a2](e2))
              return void yr(r3, a2, e2, n2);
          }
          yr(r3, "__", e2, n2);
        }, 1)];
      } else
        n(0, "expect match to be unit, function or object");
      var O2 = a({ meta: { op: i2 }, parent: t2 ? [] : v2, scope: r2, node: w2, family: { owners: Array.from(k2) }, regional: 1 });
      if (t2 && mr(i2, t2, v2, null, O2, null, i2, g2, 0, 0, 0), !h2)
        return r2;
    }, exports.step = Me, exports.version = "22.8.0", exports.withFactory = function(e2) {
      var r2 = e2.sid, n2 = e2.name, i2 = e2.loc, o2 = e2.method, u2 = e2.fn;
      return t(a({ meta: { sidRoot: te(r2), sid: r2, name: n2, loc: i2, method: o2, type: "factory" } }), u2);
    }, exports.withRegion = t;
  }
});
export default require_compat();
//# sourceMappingURL=effector_compat.js.map
